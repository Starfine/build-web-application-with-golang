# 1.3 Go 命令

## Go 命令

  Go語言自帶有一套完整的命令操作工具，你可以通過在命令行中執行`go`來查看它們：

  ![](images/1.1.mac.png?raw=true)

圖1.3 Go命令顯示詳細的信息

  這些命令對於我們平時編寫的代碼非常有用，接下來就讓我們瞭解一些常用的命令。

## go build

  這個命令主要用於編譯代碼。在包的編譯過程中，若有必要，會同時編譯與之相關聯的包。

  - 如果是普通包，就像我們在1.2節中編寫的`mymath`包那樣，當你執行`go build`之後，它不會產生任何文件。如果你需要在`$GOPATH/pkg`下生成相應的文件，那就得執行`go install`。

  - 如果是`main`包，當你執行`go build`之後，它就會在當前目錄下生成一個可執行文件。如果你需要在`$GOPATH/bin`下生成相應的文件，需要執行`go install`，或者使用`go build -o 路徑/a.exe`。

  - 如果某個項目文件夾下有多個文件，而你只想編譯某個文件，就可在`go build`之後加上文件名，例如`go build a.go`；`go build`命令默認會編譯當前目錄下的所有go文件。

  - 你也可以指定編譯輸出的文件名。例如1.2節中的`mathapp`應用，我們可以指定`go build -o astaxie.exe`，默認情況是你的package名(非main包)，或者是第一個源文件的文件名(main包)。

  （注：實際上，package名在[Go語言規範](https://golang.org/ref/spec)中指代碼中“package”後使用的名稱，此名稱可以與文件夾名不同。默認生成的可執行文件名是文件夾名。）

  - go build會忽略目錄下以“_”或“.”開頭的go文件。

  - 如果你的源代碼針對不同的操作系統需要不同的處理，那麼你可以根據不同的操作系統後綴來命名文件。例如有一個讀取數組的程序，它對於不同的操作系統可能有如下幾個源文件：

	array_linux.go
	array_darwin.go
	array_windows.go
	array_freebsd.go

  `go build`的時候會選擇性地編譯以系統名結尾的文件（Linux、Darwin、Windows、Freebsd）。例如Linux系統下面編譯只會選擇array_linux.go文件，其它系統命名後綴文件全部忽略。

參數的介紹

- `-o` 指定輸出的文件名，可以帶上路徑，例如 `go build -o a/b/c`
- `-i` 安裝相應的包，編譯+`go install`
- `-a` 更新全部已經是最新的包的，但是對標準包不適用
- `-n` 把需要執行的編譯命令打印出來，但是不執行，這樣就可以很容易的知道底層是如何運行的
- `-p n` 指定可以並行可運行的編譯數目，默認是CPU數目
- `-race` 開啟編譯的時候自動檢測數據競爭的情況，目前只支持64位的機器
- `-v` 打印出來我們正在編譯的包名
- `-work` 打印出來編譯時候的臨時文件夾名稱，並且如果已經存在的話就不要刪除
- `-x` 打印出來執行的命令，其實就是和`-n`的結果類似，只是這個會執行
- `-ccflags 'arg list'` 傳遞參數給5c, 6c, 8c 調用
- `-compiler name` 指定相應的編譯器，gccgo還是gc
- `-gccgoflags 'arg list'` 傳遞參數給gccgo編譯連接調用
- `-gcflags 'arg list'` 傳遞參數給5g, 6g, 8g 調用
- `-installsuffix suffix` 為了和默認的安裝包區別開來，採用這個前綴來重新安裝那些依賴的包，`-race`的時候默認已經是`-installsuffix race`,大家可以通過`-n`命令來驗證
- `-ldflags 'flag list'` 傳遞參數給5l, 6l, 8l 調用
- `-tags 'tag list'` 設置在編譯的時候可以適配的那些tag，詳細的tag限制參考裡面的 [Build Constraints](http://golang.org/pkg/go/build/)

## go clean

  這個命令是用來移除當前源碼包和關聯源碼包裡面編譯生成的文件。這些文件包括

	_obj/            舊的object目錄，由Makefiles遺留
	_test/           舊的test目錄，由Makefiles遺留
	_testmain.go     舊的gotest文件，由Makefiles遺留
	test.out         舊的test記錄，由Makefiles遺留
	build.out        舊的test記錄，由Makefiles遺留
	*.[568ao]        object文件，由Makefiles遺留

	DIR(.exe)        由go build產生
	DIR.test(.exe)   由go test -c產生
	MAINFILE(.exe)   由go build MAINFILE.go產生
	*.so             由 SWIG 產生

  我一般都是利用這個命令清除編譯文件，然後github遞交源碼，在本機測試的時候這些編譯文件都是和系統相關的，但是對於源碼管理來說沒必要。

	$ go clean -i -n
	cd /Users/astaxie/develop/gopath/src/mathapp
	rm -f mathapp mathapp.exe mathapp.test mathapp.test.exe app app.exe
	rm -f /Users/astaxie/develop/gopath/bin/mathapp

參數介紹

- `-i` 清除關聯的安裝的包和可運行文件，也就是通過go install安裝的文件
- `-n` 把需要執行的清除命令打印出來，但是不執行，這樣就可以很容易的知道底層是如何運行的
- `-r` 循環的清除在import中引入的包
- `-x` 打印出來執行的詳細命令，其實就是`-n`打印的執行版本

## go fmt

  有過C/C++經驗的讀者會知道,一些人經常為代碼採取K&R風格還是ANSI風格而爭論不休。在go中，代碼則有標準的風格。由於之前已經有的一些習慣或其它的原因我們常將代碼寫成ANSI風格或者其它更合適自己的格式，這將為人們在閱讀別人的代碼時添加不必要的負擔，所以go強制了代碼格式（比如左大括號必須放在行尾），不按照此格式的代碼將不能編譯通過，為了減少浪費在排版上的時間，go工具集中提供了一個`go fmt`命令 它可以幫你格式化你寫好的代碼文件，使你寫代碼的時候不需要關心格式，你只需要在寫完之後執行`go fmt <文件名>.go`，你的代碼就被修改成了標準格式，但是我平常很少用到這個命令，因為開發工具裡面一般都帶了保存時候自動格式化功能，這個功能其實在底層就是調用了`go fmt`。接下來的一節我將講述兩個工具，這兩個工具都自帶了保存文件時自動化`go fmt`功能。

使用go fmt命令，其實是調用了gofmt，而且需要參數-w，否則格式化結果不會寫入文件。gofmt -w -l src，可以格式化整個項目。

所以go fmt是gofmt的上層一個包裝的命令，我們想要更多的個性化的格式化可以參考 [gofmt](http://golang.org/cmd/gofmt/)

gofmt的參數介紹

- `-l` 顯示那些需要格式化的文件
- `-w` 把改寫後的內容直接寫入到文件中，而不是作為結果打印到標準輸出。
- `-r` 添加形如“a[b:len(a)] -> a[b:]”的重寫規則，方便我們做批量替換
- `-s` 簡化文件中的代碼
- `-d` 顯示格式化前後的diff而不是寫入文件，默認是false
- `-e` 打印所有的語法錯誤到標準輸出。如果不使用此標記，則只會打印不同行的前10個錯誤。
- `-cpuprofile` 支持調試模式，寫入相應的cpufile到指定的文件

## go get

  這個命令是用來動態獲取遠程代碼包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad。這個命令在內部實際上分成了兩步操作：第一步是下載源碼包，第二步是執行`go install`。下載源碼包的go工具會自動根據不同的域名調用不同的源碼工具，對應關係如下：

	BitBucket (Mercurial Git)
	GitHub (Git)
	Google Code Project Hosting (Git, Mercurial, Subversion)
	Launchpad (Bazaar)

  所以為了`go get` 能正常工作，你必須確保安裝了合適的源碼管理工具，並同時把這些命令加入你的PATH中。其實`go get`支持自定義域名的功能，具體參見`go help remote`。

參數介紹：

- `-d` 只下載不安裝
- `-f` 只有在你包含了`-u`參數的時候才有效，不讓`-u`去驗證import中的每一個都已經獲取了，這對於本地fork的包特別有用
- `-fix` 在獲取源碼之後先運行fix，然後再去做其他的事情
- `-t` 同時也下載需要為運行測試所需要的包
- `-u` 強制使用網絡去更新包和它的依賴包
- `-v` 顯示執行的命令

## go install

  這個命令在內部實際上分成了兩步操作：第一步是生成結果文件(可執行文件或者.a包)，第二步會把編譯好的結果移到`$GOPATH/pkg`或者`$GOPATH/bin`。

參數支持`go build`的編譯參數。大家只要記住一個參數`-v`就好了，這個隨時隨地的可以查看底層的執行信息。

## go test

  執行這個命令，會自動讀取源碼目錄下面名為`*_test.go`的文件，生成並運行測試用的可執行文件。輸出的信息類似

	ok   archive/tar   0.011s
	FAIL archive/zip   0.022s
	ok   compress/gzip 0.033s
	...

  默認的情況下，不需要任何的參數，它會自動把你源碼包下面所有test文件測試完畢，當然你也可以帶上參數，詳情請參考`go help testflag`

這裡我介紹幾個我們常用的參數：

- `-bench regexp` 執行相應的benchmarks，例如 `-bench=.`
- `-cover` 開啟測試覆蓋率
- `-run regexp` 只運行regexp匹配的函數，例如 `-run=Array` 那麼就執行包含有Array開頭的函數
- `-v` 顯示測試的詳細命令

## go tool
`go tool`下面下載聚集了很多命令，這裡我們只介紹兩個，fix和vet

- `go tool fix .` 用來修復以前老版本的代碼到新版本，例如go1之前老版本的代碼轉化到go1,例如API的變化
- `go tool vet directory|files` 用來分析當前目錄的代碼是否都是正確的代碼,例如是不是調用fmt.Printf裡面的參數不正確，例如函數裡面提前return瞭然後出現了無用代碼之類的。

## go generate
這個命令是從Go1.4開始才設計的，用於在編譯前自動化生成某類代碼。`go generate`和`go build`是完全不一樣的命令，通過分析源碼中特殊的註釋，然後執行相應的命令。這些命令都是很明確的，沒有任何的依賴在裡面。而且大家在用這個之前心裡面一定要有一個理念，這個`go generate`是給你用的，不是給使用你這個包的人用的，是方便你來生成一些代碼的。

這裡我們來舉一個簡單的例子，例如我們經常會使用`yacc`來生成代碼，那麼我們常用這樣的命令：

	go tool yacc -o gopher.go -p parser gopher.y

-o 指定了輸出的文件名， -p指定了package的名稱，這是一個單獨的命令，如果我們想讓`go generate`來觸發這個命令，那麼就可以在當然目錄的任意一個`xxx.go`文件裡面的任意位置增加一行如下的註釋：

	//go:generate go tool yacc -o gopher.go -p parser gopher.y

這裡我們注意了，`//go:generate`是沒有任何空格的，這其實就是一個固定的格式，在掃描源碼文件的時候就是根據這個來判斷的。

所以我們可以通過如下的命令來生成，編譯，測試。如果`gopher.y`文件有修改，那麼就重新執行`go generate`重新生成文件就好。

	$ go generate
	$ go build
	$ go test


## godoc

在Go1.2版本之前還支持`go doc`命令，但是之後全部移到了godoc這個命令下，需要這樣安裝`go get golang.org/x/tools/cmd/godoc`

  很多人說go不需要任何的第三方文檔，例如chm手冊之類的（其實我已經做了一個了，[chm手冊](https://github.com/astaxie/godoc)），因為它內部就有一個很強大的文檔工具。

  如何查看相應package的文檔呢？
  例如builtin包，那麼執行`godoc builtin`
  如果是http包，那麼執行`godoc net/http`
  查看某一個包裡面的函數，那麼執行`godoc fmt Printf`
  也可以查看相應的代碼，執行`godoc -src fmt Printf`

  通過命令在命令行執行 godoc -http=:端口號 比如`godoc -http=:8080`。然後在瀏覽器中打開`127.0.0.1:8080`，你將會看到一個golang.org的本地copy版本，通過它你可以查詢pkg文檔等其它內容。如果你設置了GOPATH，在pkg分類下，不但會列出標準包的文檔，還會列出你本地`GOPATH`中所有項目的相關文檔，這對於經常被牆的用戶來說是一個不錯的選擇。

## 其它命令

  go還提供了其它很多的工具，例如下面的這些工具

	go version 查看go當前的版本
	go env 查看當前go的環境變量
	go list 列出當前全部安裝的package
	go run 編譯並運行Go程序

以上這些工具還有很多參數沒有一一介紹，用戶可以使用`go help 命令`獲取更詳細的幫助信息。


## links
   * [目錄](<preface.md>)
   * 上一節: [GOPATH與工作空間](<01.2.md>)
   * 下一節: [Go開發工具](<01.4.md>)

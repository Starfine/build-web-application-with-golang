# 11.3 Go怎麼寫測試用例
開發程序其中很重要的一點是測試，我們如何保證代碼的質量，如何保證每個函數是可運行，運行結果是正確的，又如何保證寫出來的代碼性能是好的，我們知道單元測試的重點在於發現程序設計或實現的邏輯錯誤，使問題及早暴露，便於問題的定位解決，而性能測試的重點在於發現程序設計上的一些問題，讓線上的程序能夠在高併發的情況下還能保持穩定。本小節將帶著這一連串的問題來講解Go語言中如何來實現單元測試和性能測試。

Go語言中自帶有一個輕量級的測試框架`testing`和自帶的`go test`命令來實現單元測試和性能測試，`testing`框架和其他語言中的測試框架類似，你可以基於這個框架寫針對相應函數的測試用例，也可以基於該框架寫相應的壓力測試用例，那麼接下來讓我們一一來看一下怎麼寫。

## 如何編寫測試用例
由於`go test`命令只能在一個相應的目錄下執行所有文件，所以我們接下來新建一個項目目錄`gotest`,這樣我們所有的代碼和測試代碼都在這個目錄下。

接下來我們在該目錄下面創建兩個文件：gotest.go和gotest_test.go

1. gotest.go:這個文件裡面我們是創建了一個包，裡面有一個函數實現了除法運算:

		package gotest
		
		import (
			"errors"
		)
		
		func Division(a, b float64) (float64, error) {
			if b == 0 {
				return 0, errors.New("除數不能為0")
			}
		
			return a / b, nil
		}

2. gotest_test.go:這是我們的單元測試文件，但是記住下面的這些原則：

	- 文件名必須是`_test.go`結尾的，這樣在執行`go test`的時候才會執行到相應的代碼
	- 你必須import `testing`這個包
	- 所有的測試用例函數必須是`Test`開頭
	- 測試用例會按照源代碼中寫的順序依次執行
	- 測試函數`TestXxx()`的參數是`testing.T`，我們可以使用該類型來記錄錯誤或者是測試狀態
	- 測試格式：`func TestXxx (t *testing.T)`,`Xxx`部分可以為任意的字母數字的組合，但是首字母不能是小寫字母[a-z]，例如`Testintdiv`是錯誤的函數名。
	- 函數中通過調用`testing.T`的`Error`, `Errorf`, `FailNow`, `Fatal`, `FatalIf`方法，說明測試不通過，調用`Log`方法用來記錄測試的信息。
	
	下面是我們的測試用例的代碼：
	
		package gotest
		
		import (
			"testing"
		)
		
		func Test_Division_1(t *testing.T) {
			if i, e := Division(6, 2); i != 3 || e != nil { //try a unit test on function
				t.Error("除法函數測試沒通過") // 如果不是如預期的那麼就報錯
			} else {
				t.Log("第一個測試通過了") //記錄一些你期望記錄的信息
			}
		}
		
		func Test_Division_2(t *testing.T) {
			t.Error("就是不通過")
		}

	我們在項目目錄下面執行`go test`,就會顯示如下信息：

		--- FAIL: Test_Division_2 (0.00 seconds)
			gotest_test.go:16: 就是不通過
		FAIL
		exit status 1
		FAIL	gotest	0.013s
	從這個結果顯示測試沒有通過，因為在第二個測試函數中我們寫死了測試不通過的代碼`t.Error`，那麼我們的第一個函數執行的情況怎麼樣呢？默認情況下執行`go test`是不會顯示測試通過的信息的，我們需要帶上參數`go test -v`，這樣就會顯示如下信息：
	
		=== RUN Test_Division_1
		--- PASS: Test_Division_1 (0.00 seconds)
			gotest_test.go:11: 第一個測試通過了
		=== RUN Test_Division_2
		--- FAIL: Test_Division_2 (0.00 seconds)
			gotest_test.go:16: 就是不通過
		FAIL
		exit status 1
		FAIL	gotest	0.012s
	上面的輸出詳細的展示了這個測試的過程，我們看到測試函數1`Test_Division_1`測試通過，而測試函數2`Test_Division_2`測試失敗了，最後得出結論測試不通過。接下來我們把測試函數2修改成如下代碼：
	
		func Test_Division_2(t *testing.T) {
			if _, e := Division(6, 0); e == nil { //try a unit test on function
				t.Error("Division did not work as expected.") // 如果不是如預期的那麼就報錯
			} else {
				t.Log("one test passed.", e) //記錄一些你期望記錄的信息
			}
		}	
	然後我們執行`go test -v`，就顯示如下信息，測試通過了：
	
		=== RUN Test_Division_1
		--- PASS: Test_Division_1 (0.00 seconds)
			gotest_test.go:11: 第一個測試通過了
		=== RUN Test_Division_2
		--- PASS: Test_Division_2 (0.00 seconds)
			gotest_test.go:20: one test passed. 除數不能為0
		PASS
		ok  	gotest	0.013s

## 如何編寫壓力測試
壓力測試用來檢測函數(方法）的性能，和編寫單元功能測試的方法類似,此處不再贅述，但需要注意以下幾點：

- 壓力測試用例必須遵循如下格式，其中XXX可以是任意字母數字的組合，但是首字母不能是小寫字母

		func BenchmarkXXX(b *testing.B) { ... }
		
- `go test`不會默認執行壓力測試的函數，如果要執行壓力測試需要帶上參數`-test.bench`，語法:`-test.bench="test_name_regex"`,例如`go test -test.bench=".*"`表示測試全部的壓力測試函數
- 在壓力測試用例中,請記得在循環體內使用`testing.B.N`,以使測試可以正常的運行
- 文件名也必須以`_test.go`結尾

下面我們新建一個壓力測試文件webbench_test.go，代碼如下所示：

	package gotest
	
	import (
		"testing"
	)
	
	func Benchmark_Division(b *testing.B) {
		for i := 0; i < b.N; i++ { //use b.N for looping 
			Division(4, 5)
		}
	}
	
	func Benchmark_TimeConsumingFunction(b *testing.B) {
		b.StopTimer() //調用該函數停止壓力測試的時間計數
	
		//做一些初始化的工作,例如讀取文件數據,數據庫連接之類的,
		//這樣這些時間不影響我們測試函數本身的性能
	
		b.StartTimer() //重新開始時間
		for i := 0; i < b.N; i++ {
			Division(4, 5)
		}
	}


我們執行命令`go test -file webbench_test.go -test.bench=".*"`，可以看到如下結果：

	PASS
	Benchmark_Division	500000000	         7.76 ns/op
	Benchmark_TimeConsumingFunction	500000000	         7.80 ns/op
	ok  	gotest	9.364s	

上面的結果顯示我們沒有執行任何`TestXXX`的單元測試函數，顯示的結果只執行了壓力測試函數，第一條顯示了`Benchmark_Division`執行了500000000次，每次的執行平均時間是7.76納秒，第二條顯示了`Benchmark_TimeConsumingFunction`執行了500000000，每次的平均執行時間是7.80納秒。最後一條顯示總共的執行時間。

## 小結
通過上面對單元測試和壓力測試的學習，我們可以看到`testing`包很輕量，編寫單元測試和壓力測試用例非常簡單，配合內置的`go test`命令就可以非常方便的進行測試，這樣在我們每次修改完代碼,執行一下go test就可以簡單的完成迴歸測試了。


## links
   * [目錄](<preface.md>)
   * 上一節: [使用GDB調試](<11.2.md>)
   * 下一節: [小結](<11.4.md>)
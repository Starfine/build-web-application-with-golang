# 6.4 預防session劫持
session劫持是一種廣泛存在的比較嚴重的安全威脅，在session技術中，客戶端和服務端通過session的標識符來維護會話， 但這個標識符很容易就能被嗅探到，從而被其他人利用.它是中間人攻擊的一種類型。

本節將通過一個實例來演示會話劫持，希望通過這個實例，能讓讀者更好地理解session的本質。
## session劫持過程
我們寫了如下的代碼來展示一個count計數器：

	func count(w http.ResponseWriter, r *http.Request) {
		sess := globalSessions.SessionStart(w, r)
		ct := sess.Get("countnum")
		if ct == nil {
			sess.Set("countnum", 1)
		} else {
			sess.Set("countnum", (ct.(int) + 1))
		}
		t, _ := template.ParseFiles("count.gtpl")
		w.Header().Set("Content-Type", "text/html")
		t.Execute(w, sess.Get("countnum"))
	}


count.gtpl的代碼如下所示：

	Hi. Now count:{{.}}

然後我們在瀏覽器裡面刷新可以看到如下內容：

![](images/6.4.hijack.png?raw=true)

圖6.4 瀏覽器端顯示count數

隨著刷新，數字將不斷增長，當數字顯示為6的時候，打開瀏覽器(以chrome為例）的cookie管理器，可以看到類似如下的信息：


![](images/6.4.cookie.png?raw=true)

圖6.5 獲取瀏覽器端保存的cookie

下面這個步驟最為關鍵: 打開另一個瀏覽器(這裡我打開了firefox瀏覽器),複製chrome地址欄裡的地址到新打開的瀏覽器的地址欄中。然後打開firefox的cookie模擬插件，新建一個cookie，把按上圖中cookie內容原樣在firefox中重建一份:

![](images/6.4.setcookie.png?raw=true)

圖6.6 模擬cookie

回車後，你將看到如下內容：

![](images/6.4.hijacksuccess.png?raw=true)

圖6.7 劫持session成功

可以看到雖然換了瀏覽器，但是我們卻獲得了sessionID，然後模擬了cookie存儲的過程。這個例子是在同一臺計算機上做的，不過即使換用兩臺來做，其結果仍然一樣。此時如果交替點擊兩個瀏覽器裡的鏈接你會發現它們其實操縱的是同一個計數器。不必驚訝，此處firefox盜用了chrome和goserver之間的維持會話的鑰匙，即gosessionid，這是一種類型的“會話劫持”。在goserver看來，它從http請求中得到了一個gosessionid，由於HTTP協議的無狀態性，它無法得知這個gosessionid是從chrome那裡“劫持”來的，它依然會去查找對應的session，並執行相關計算。與此同時 chrome也無法得知自己保持的會話已經被“劫持”。
## session劫持防範
### cookieonly和token
通過上面session劫持的簡單演示可以瞭解到session一旦被其他人劫持，就非常危險，劫持者可以假裝成被劫持者進行很多非法操作。那麼如何有效的防止session劫持呢？

其中一個解決方案就是sessionID的值只允許cookie設置，而不是通過URL重置方式設置，同時設置cookie的httponly為true,這個屬性是設置是否可通過客戶端腳本訪問這個設置的cookie，第一這個可以防止這個cookie被XSS讀取從而引起session劫持，第二cookie設置不會像URL重置方式那麼容易獲取sessionID。

第二步就是在每個請求裡面加上token，實現類似前面章節裡面講的防止form重複遞交類似的功能，我們在每個請求裡面加上一個隱藏的token，然後每次驗證這個token，從而保證用戶的請求都是唯一性。

	h := md5.New()
	salt:="astaxie%^7&8888"
	io.WriteString(h,salt+time.Now().String())
	token:=fmt.Sprintf("%x",h.Sum(nil))
	if r.Form["token"]!=token{
		//提示登錄
	}
	sess.Set("token",token)


### 間隔生成新的SID
還有一個解決方案就是，我們給session額外設置一個創建時間的值，一旦過了一定的時間，我們銷燬這個sessionID，重新生成新的session，這樣可以一定程度上防止session劫持的問題。

	createtime := sess.Get("createtime")
	if createtime == nil {
		sess.Set("createtime", time.Now().Unix())
	} else if (createtime.(int64) + 60) < (time.Now().Unix()) {
		globalSessions.SessionDestroy(w, r)
		sess = globalSessions.SessionStart(w, r)
	}

session啟動後，我們設置了一個值，用於記錄生成sessionID的時間。通過判斷每次請求是否過期(這裡設置了60秒)定期生成新的ID，這樣使得攻擊者獲取有效sessionID的機會大大降低。

上面兩個手段的組合可以在實踐中消除session劫持的風險，一方面，	由於sessionID頻繁改變，使攻擊者難有機會獲取有效的sessionID；另一方面，因為sessionID只能在cookie中傳遞，然後設置了httponly，所以基於URL攻擊的可能性為零，同時被XSS獲取sessionID也不可能。最後，由於我們還設置了MaxAge=0，這樣就相當於session cookie不會留在瀏覽器的歷史記錄裡面。


## links
   * [目錄](<preface.md>)
   * 上一節: [session存儲](<06.3.md>)
   * 下一節: [小結](<06.5.md>)
